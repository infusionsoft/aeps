# Resource-oriented design

Resource-oriented design is a pattern for specifying [REST][] APIs, based on the
following high-level design principles:

- The fundamental building blocks of an API are individually named _resources_
  (nouns) and the relationships and hierarchy that exist between them.
- A small number of standard _methods_ (verbs) provide the semantics for most
  common operations. When the standard methods do not fit, custom methods may
  be introduced as a last resort.

These principles align with core [REST][] concepts such as resources, uniform
interface, and representations. This AEP focuses on applying resource-oriented
design to REST APIs.

## Guidance

When designing a REST API, consider the following:

- The resources (nouns) the API will expose.
- The relationships and hierarchies between those resources.
- The schema (representation) of each resource.
- The methods (HTTP verbs) each resource supports, relying as much as possible
  on the standard verbs.

### Resources

A resource-oriented REST API **must** be modeled as a resource hierarchy, where
each node is either a simple resource or a collection of resources.

A [collection][] contains resources of _the same type_. For
example, a publisher has the collection of books that it publishes. A resource
usually has fields, and resources may have any number of sub-resources (usually
collections).

**Note:** While there is some conceptual alignment between storage systems and
APIs, a service with a resource-oriented API is not necessarily a database and
has enormous flexibility in how it interprets resources and methods. API
designers **should not** expect that their API will be reflective of their
database schema. In fact, having an API that is identical to the underlying
database schema is actually an antipattern, as it tightly couples the surface
to the underlying system.

### Methods

Resource-oriented REST APIs emphasize resources (data model) over the methods
performed on those resources (functionality). A typical REST API exposes a large
number of resources with a small number of methods on each resource. The
methods can be either the standard methods ([Get][], [List][], [Create][],
[Update][], [Delete][]), or carefully designed [custom methods][].

If the request to, or the response from, a standard method (or a custom method in
the same _service_) **is** the resource or **contains** the resource, the
resource schema for that resource across all methods **must** be the same.

| Operation | HTTP method (verb) | Request body          | Response body   |
|-----------|--------------------|-----------------------|-----------------|
| Create    | `POST`             | Contains the resource | Is the resource |
| Get       | `GET`              | None                  | Is the resource |
| Update    | `PATCH` or `PUT`   | Contains the resource | Is the resource |
| Delete    | `DELETE`           | None                  | None (204)      |
| List      | `GET`              | None                  | Is the resource |

_The table above describes each operation's relationship to the resource,
where "None" indicates that the resource neither **is**, nor **is contained**, in
the request or the response._

A resource **must** support at minimum [Get][]: clients must be able to
validate the state of resources after performing a mutation such as [Create][],
[Update][], or [Delete][].

A resource **must** also support [List][], except for [singleton resources][]
where more than one resource is not possible.

**Custom methods (actions):** In REST, do not invent new HTTP verbs. Prefer the
standard methods above. When domain-specific operations do not cleanly map to
standard methods, model them as actions:

- Represent the action as a sub-resource or action-style endpoint, invoked with
  `POST` (e.g., `/books/{book}:publish` or `/emails/{email}:send`).
- Avoid using generic verbs in resource names when a field update suffices; if
  an operation changes resource state, consider whether it should instead be an
  [Update][] with a clearly defined field.

APIs **should** prefer standard methods over custom actions; actions exist to
express functionality that does not cleanly map to the standard methods.

### Strong Consistency

TL;DR: Changes should be visible immediately after an operation completes.

A method is strongly consistent if changes are immediately visible after an operation completes. When you create,
update, or delete a resource, any subsequent GET request **should** reflect that change until another modification is
made.

User-settable fields (fields that clients provide) **must** return the same value on all subsequent requests after an
operation completes, until another mutation changes the resource.

[Output only][output only] fields (system-managed fields like `created_at`, `status`, or IDs) **should** also return
consistent values after an operation completes.

- However, there's an exception for fields that represent "live state" that takes significant time to stabilize (for
  example, a field tracking the instantiation status of a VM cluster that takes an hour to fully provision).

Examples of strong consistency include:

- Following a successful create that is the latest mutation on a resource, a get request for a resource **must** return
  the resource.
- Following a successful update that is the latest mutation on a resource, a get request for a resource **must** return
  the final values from the update request.
- Following a successful delete that is the latest mutation on a resource, a get request for a resource **must** return
  `NOT_FOUND` (or the resource with the `DELETED` state value in the case of [soft delete][], if applicable)

**Why strong consistency matters**:

Clients often need to perform multiple operations in sequence (for example, create resource A, then create resource B
that depends on A). Strong consistency ensures that when an operation completes, clients can immediately proceed to the
next step without worrying whether their changes are visible yet.

Output only fields ideally follow the same guidelines, but since these fields often represent a resource's live state,
they may sometimes need to change after a mutation operation to reflect ongoing state transitions.

### Cyclic References

TL;DR: Don't make resources that reference each other in circles; it makes CRUD operations unnecessarily complex.

The relationship between resources, such as parent-child or [resource
references][], **must** be representable via a [directed acyclic graph][]. In simpler terms: don't design resources that
reference each other in circles.

**Why circular references are problematic**:

Cyclic relationships make resource management unnecessarily complex. Consider two resources, A and B, that need to
reference each other:

1. Create resource A without a reference to B (because B doesn't exist yet). Get A's ID.
2. Create resource B with a reference to A. Get B's ID.
3. Update resource A to add the reference to B.

This requires three operations instead of two, just to create two related resources.

Deletion also becomes more complex because you must figure out which resource to dereference first for successful
deletion.

**Exception**:

This requirement does not apply to relationships expressed via [output only][] fields (system-managed references). Since
users don't have to manually specify these values, they don't increase resource management complexity.

**Good alternatives to circular references**:

- Use parent-child relationships (one-way): `Order → Items`
- Use intermediate linking resources: `User → Membership ← Team`
- Allow cyclic relationships only in system-generated fields that clients don't manage

[create]: ./0133

[custom methods]: ./0136

[delete]: ./0135

[directed acyclic graph]: https://en.wikipedia.org/wiki/Directed_acyclic_graph

[get]: ./0131

[list]: ./0132

[output only]: ./0203#output-only

[rest]: ./10

[collection]: ./9#collection

[resource references]: ./0122#fields-representing-another-resource

[singleton resources]: ./0156

[soft delete]: ./0164

[state]: ./0216

[update]: ./0134

## Changelog

- **2025-11-04**: Initial AIP-121 for Thryv, adapted from [Google AIP-121][] and aep.dev [AEP-121][].

[Google AIP-121]: https://google.aip.dev/121

[AEP-121]: https://aep.dev/121
